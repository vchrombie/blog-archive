{"componentChunkName":"component---node-modules-lekoarts-gatsby-theme-minimal-blog-core-src-templates-post-query-tsx","path":"/bdd-python-behave","result":{"data":{"post":{"__typename":"MdxPost","slug":"/bdd-python-behave","title":"BDD with Python and Behave","date":"02.03.2022","tags":[{"name":"python","slug":"python"},{"name":"behave","slug":"behave"},{"name":"bdd","slug":"bdd"}],"description":null,"canonicalUrl":null,"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"BDD with Python and Behave\",\n  \"date\": \"2022-03-02T00:00:00.000Z\",\n  \"tags\": [\"python\", \"behave\", \"bdd\"],\n  \"slug\": \"bdd-python-behave\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h3\", null, \"Introduction\"), mdx(\"p\", null, \"Behavior Driven Development (BDD) is an agile software development technique that mainly encourages collaboration between developers, non-technical or business participants in a software project. In short, both technical and non-technical individuals have a role to play towards the overall project. It has tests developed in plain text with the implementation logic in Python.\"), mdx(\"p\", null, \"By the end of this tutorial, you should be able to write basic behavioral tests using \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/behave/behave\"\n  }, \"Behave\"), \".\"), mdx(\"h3\", null, \"Prerequisites\"), mdx(\"p\", null, \"Before starting, please make sure you have installed the following:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://www.python.org/downloads/\"\n  }, \"Python 3.x\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://pypi.org/project/behave/\"\n  }, \"Behave\"))), mdx(\"h3\", null, \"Setting Up Your Environment\"), mdx(\"p\", null, \"This tutorial will walk you through writing tests for and coding a feature of a Simple Calculator. To get started, create a root directory where your code will go, and then create the following directories and blank files:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-bash\"\n  }, \"$ tree\\n.\\n|____features\\n| |____calculator.feature\\n| |____steps\\n|   |____steps.py\\n|____calculator.py\\n\")), mdx(\"p\", null, \"Here\\u2019s a brief explanation of the files:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"calculator.feature\"), \": The written out tests for the calculator.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"steps.py\"), \": The code that runs the tests in calculator.feature.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"calculator.py\"), \": The implementation code for the calculator.\")), mdx(\"h3\", null, \"Writing Your First Test\"), mdx(\"p\", null, \"Behavioral tests are much similar to TDD methodology. We will start with the tests first.\"), mdx(\"h4\", null, \"Writing the Scenario\"), mdx(\"p\", null, \"Open \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"calculator.feature\"), \" and add the following first line:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-feature\"\n  }, \"Feature: Test Calculator Functionality\\n\")), mdx(\"p\", null, \"This line describes the features of the application. For our project, Calculator, we might not have many features but in large scale application we would have many features. Next, we will add a test. The first test would be very simple - \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Add two numbers\"), \".\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-feature\"\n  }, \"Feature: Test Calculator Functionality\\n  Scenario: Add two numbers\\n\")), mdx(\"p\", null, \"Before we write more, we need to understand the three phases of a basic Behave test: \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Given\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"When\"), \", and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Then\"), \".\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Given\"), \" initializes a state, \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"When\"), \" describes an action, and \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Then\"), \" states the expected outcome. For this test, our state is having the two numbers, the action is adding them, and the expected outcome is that expecting the result to be sum of the two numbers. Here\\u2019s how this is translated into a Behave test:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-feature\"\n  }, \"Feature: Test Calculator Functionality=\\n  Scenario: Addition\\n      Given I have the numbers 10 and 5\\n      When I add them\\n      Then I expect the result to be 15\\n\")), mdx(\"p\", null, \"Notice that the three phases read like a normal English sentence. You should strive for this when writing behavioral tests because they are easily readable by anyone working in the code base (need not be a developer).\"), mdx(\"p\", null, \"Now to see how Behave works, simply open a terminal in the root directory of your code and run the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"behave\"), \" command and you should see the output.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-bash\"\n  }, \"$ behave\\nFeature: Test Calculator Functionality # features/calculator.feature:2\\n\\n  Scenario: Addition                  # features/calculator.feature:4\\n    Given I have the numbers 10 and 5 # None\\n    When I add them                   # None\\n    Then I expect the result to be 15 # None\\n\\n\\nFailing scenarios:\\n  features/calculator.feature:4  Addition\\n\\n0 features passed, 1 failed, 0 skipped\\n0 scenarios passed, 1 failed, 0 skipped\\n0 steps passed, 0 failed, 0 skipped, 3 undefined\\nTook 0m0.000s\\n\\n...\\n\")), mdx(\"p\", null, \"The key part here is that we have one failing scenario (and therefore a failing feature) that we need to fix. Below that, Behave suggests how to implement steps. You can think of a step as a task for Behave to execute. Each phase (\\u201Cgiven\\u201D, \\u201Cwhen\\u201D, and \\u201Cthen\\u201D) are all implemented as steps.\"), mdx(\"h4\", null, \"Writing the Steps\"), mdx(\"p\", null, \"The steps that Behave runs are written in Python and they are the link between the descriptive tests in \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \".feature\"), \" files and the actual application code. Go ahead and open \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"steps.py\"), \" and add the following imports:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-py\"\n  }, \"from behave import given, when, then\\nfrom calculator import Calculator\\n\")), mdx(\"p\", null, \"Behave steps use annotations that match the names of the phases. This is the first step as described in the scenario:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-py\"\n  }, \"@given(u'I have the numbers {num1} and {num2}')\\ndef step_impl(context, num1, num2):\\n    print(u'STEP: Given I have the numbers {} and {}'.format(num1, num2))\\n    context.num1 = int(num1)\\n    context.num2 = int(num2)\\n\")), mdx(\"p\", null, \"It\\u2019s important to notice that the text inside of the annotation matches the scenario text exactly. If it doesn\\u2019t match, the test cannot run.\"), mdx(\"p\", null, \"The context object is passed from step to step, and it is where we can store information to be used by other steps. Since this step is a \\u201Cgiven\\u201D, we need to initialize our state. We do that by storing our numbers in \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"num1\"), \" & \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"num2\"), \" variables and attaching them to the context. If you run behave again, you\\u2019ll see the test fails, because the \\u201Cwhen\\u201D and \\u201Cthen\\u201D steps are not implemented. You can run behave command after each step to see how the tests are working.\"), mdx(\"p\", null, \"Here are the next steps to add to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"steps.py\"), \":\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-py\"\n  }, \"@when(u'I add them')\\ndef step_impl(context, opr):\\n    print(u'STEP: When I add them')\\n    context.result = Calculator().add(\\n        context.num1,\\n        context.num2\\n    )\\n\")), mdx(\"p\", null, \"Again, the annotation text matches the text in the scenario exactly. In the \\u201Cwhen\\u201D step, we have access to the two numbers using context and we call the Calculator class to call the add method with the numbers.\"), mdx(\"p\", null, \"Finally, in the \\u201Cthen\\u201D step, we still have access to the numbers and their sum, and we assert that the result is equal to the expected sum.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-py\"\n  }, \"@then(u'I expect the result to be {result}')\\ndef step_impl(context, result):\\n    print(u'STEP: Then I expect the result to be {}'.format(result))\\n    assert context.result == int(result),\\n    'Expected {}, got {}'.format(result, context.result)\\n\")), mdx(\"p\", null, \"We are done with the tests now, let's switch to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"calculator.py\"), \" and define the add method:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-py\"\n  }, \"#!/usr/bin/env python3\\n\\nclass Calculator:\\n    def __init__(self, caching=True):\\n        \\\"\\\"\\\" init \\\"\\\"\\\"\\n        pass\\n\\n    def add(self, xxx, yyy):\\n        \\\"\\\"\\\" addition \\\"\\\"\\\"\\n        return xxx + yyy\\n\")), mdx(\"p\", null, \"Everything looks good, let's go ahead and run the behave command again and you should see that the test passes:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-bash\"\n  }, \"$ behave\\nFeature: Test Calculator Functionality # features/calculator.feature:2\\n\\n  Scenario: Addition                  # features/calculator.feature:4\\n    Given I have the numbers 10 and 5 # features/steps/steps.py:5 0.000s\\n    When I add them                   # features/steps/steps.py:12 0.000s\\n    Then I expect the result to be 15 # features/steps/steps.py:21 0.000s\\n\\n1 feature passed, 0 failed, 0 skipped\\n1 scenario passed, 0 failed, 0 skipped\\n3 steps passed, 0 failed, 0 skipped, 0 undefined\\nTook 0m0.001s\\n\\n\")), mdx(\"h3\", null, \"Extending the Calculator\"), mdx(\"p\", null, \"Now that we have addition, let's add multiplication too.\"), mdx(\"p\", null, \"As mentioned above, we will add the tests first in \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"calculator.feature\"), \" file:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-feature\"\n  }, \"  Scenario: Multiplication\\n      Given I have the numbers 10 and 5\\n      When I mult them\\n      Then I expect the result to be 50\\n\")), mdx(\"p\", null, \"Next, we are add the implementation in the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"steps.py\"), \". Also, see that the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Given\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Then\"), \" looks similar to that of the Addition scenario, so we don't need to define them again.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-py\"\n  }, \"@when(u'I mult them')\\ndef step_impl(context, opr):\\n    print(u'STEP: When I mult them')\\n    context.result = Calculator().mult(\\n        context.num1,\\n        context.num2\\n    )\\n\")), mdx(\"p\", null, \"And lastly, implement the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"mult\"), \" method in the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"calculator.py\"), \" file:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-py\"\n  }, \"#!/usr/bin/env python3\\n\\nclass Calculator:\\n    ...\\n\\n    def mult(self, xxx, yyy):\\n        \\\"\\\"\\\" multiply \\\"\\\"\\\"\\n        return xxx * yyy\\n\")), mdx(\"p\", null, \"When you run the behave command again, you can see that all the tests pass (1 Feature, 2 Scenarios and 6 Steps).\"), mdx(\"h3\", null, \"Optimizing the tests and code\"), mdx(\"p\", null, \"You can see that the steps implementation have a lot in common. So, we can try to optimize it by parsing the arithmetic operation also as a variable in the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"steps.py\"), \":\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-py\"\n  }, \"@when(u'I {opr} them')\\ndef step_impl(context, opr):\\n    print(u'STEP: When I add them')\\n    context.result = Calculator().operator(\\n        opr,\\n        context.num1,\\n        context.num2\\n    )\\n\")), mdx(\"p\", null, \"and the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"calculator.py\"), \" should look something like:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-py\"\n  }, \"class Calculator(object):\\n    def __init__(self, caching=True):\\n        \\\"\\\"\\\" init \\\"\\\"\\\"\\n        pass\\n\\n    def add(self, xxx, yyy):\\n        \\\"\\\"\\\" addition \\\"\\\"\\\"\\n        return xxx + yyy\\n\\n    def mult(self, xxx, yyy):\\n        \\\"\\\"\\\" multiply \\\"\\\"\\\"\\n        return xxx * yyy\\n\\n    def operator(self, opr, xxx, yyy):\\n        if opr == 'add':\\n            return self.add(xxx, yyy)\\n        elif opr == 'mult':\\n            return self.mult(xxx, yyy)\\n\")), mdx(\"h3\", null, \"Environmental Controls\"), mdx(\"p\", null, \"Similar to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"setUp\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"tearDown\"), \" in unit tests, the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://behave.readthedocs.io/en/stable/tutorial.html#environmental-controls\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"environment.py\"), \" module\"), \" can define code to run before and after certain events during your testing. We can use this to initialize the Calculator class since we need it in every scenario.\"), mdx(\"p\", null, \"Create \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"environment.py\"), \" file in the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"features/\"), \" folder and add the following code:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-py\"\n  }, \"from calculator import Calculator\\n\\n\\ndef before_all(context):\\n    context.calculator = Calculator()\\n\\n\\ndef after_all(context):\\n    del context.calculator\\n\")), mdx(\"p\", null, \"This would initialize the Calculator before everything and stores it in the context so that we can use it in any step. With this, we can change the code in \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"steps.py\"), \" as:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-py\"\n  }, \"@when(u'I {opr} them')\\ndef step_impl(context, opr):\\n    print(u'STEP: When I add them')\\n    context.result = context.calculator.operator(\\n        opr,\\n        context.num1,\\n        context.num2\\n    )\\n\")), mdx(\"h3\", null, \"Conclusion\"), mdx(\"p\", null, \"This tutorial walked you through setting up a new project with the Behave library and using test-driven development to build a calculator based off of behavioral tests.\"), mdx(\"p\", null, \"If you would like to get experience writing more tests with this project, try implementing the division, modulus and other arithmetic and advanced operations.\"), mdx(\"h3\", null, \"Resources\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"You can find the full source code of the implementation: \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://github.com/vchrombie/bdd-testing-behave\"\n  }, \"vchrombie/bdd-testing-behave\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Tutorial \", \"\\u2014\", \" behave documentation: \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://behave.readthedocs.io/en/stable/tutorial.html\"\n  }, \"https://behave.readthedocs.io/en/stable/tutorial.html\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"BDD Quickstart with Python: \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://blog.visionify.ai/bdd-quickstart-with-python-4cf366cfc11c\"\n  }, \"https://blog.visionify.ai/bdd-quickstart-with-python-4cf366cfc11c\"))), mdx(\"p\", null, \"Have a comment? You can drop it below.\"), mdx(\"p\", null, \"adios \\uD83D\\uDC4B\"));\n}\n;\nMDXContent.isMDXComponent = true;","excerpt":"Introduction Behavior Driven Development (BDD) is an agile software development technique that mainly encourages collaboration between…","timeToRead":4,"banner":null}},"pageContext":{"slug":"/bdd-python-behave","formatString":"DD.MM.YYYY"}},"staticQueryHashes":["3090400250","3090400250","318001574"]}